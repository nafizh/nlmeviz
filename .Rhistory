S = matrix(0, nrow = 4, ncol = 4)
for(j in 1:nrow(PAM10)) {
for(k in 1:ncol(PAM10)) {
S[j,k] = log(PAM10[j,k]/q[k])
}
}
rownames(S) = c('A','G','C','T')
colnames(S) = c('A','G','C','T')
excursions <- data.frame(Score = rep(0,n + 1), Ladder = rep(NA, n +1), exc_height = rep(0, n+1), max_height = rep(0, n+ 1))
excursions[1,2] <- TRUE
for(i in 1:n) {
# Calculate Score
excursions[i + 1,1] <- S[seq1[i], seq2[i]]
# Calculate height
excursions[i + 1,3] <- excursions[i, 3] + S[seq1[i], seq2[i]]
# Determine ladder points
if(excursions[i + 1, 3] < excursions[i, 3]) {
excursions[i + 1,2] <- TRUE
excursions[i, 2] <- FALSE
} else {
excursions[i + 1, 2] <- FALSE
}
}
i = 2
while(i <= n) {
max = 0
while(excursions[i,2] == FALSE) {
if(excursions[i,3] > excursions[i- 1,3]) {
max = excursions[i,3]
}
i = i + 1
}
excursions[i,4] = max
i = i + 1
}
lambda = 0
for(j in 1:4) {
for(k in 1:4) {
lambda = lambda + log(1/(p[j] * q[k]))/S[j,k]
}
}
names(lambda) <- c('lambda')
lambda
for(i in 1:n) {
seq1[i] = sample(c('A','G','C','T'),1, prob = PAM10[seq1[i - 1], ])
seq2[i] = sample(c('A','G','C','T'),1,prob = PAM10[seq2[i - 1], ])
}
for(i in 1:n) {
seq1[i] = sample(c('A','G','C','T'), 1, prob = pi)
seq2[i] = sample(c('A','G','C','T'), 1, prob = pi)
#   seq1[i] = sample(c('A','G','C','T'),1, prob = PAM10[seq1[i - 1], ])
#  seq2[i] = sample(c('A','G','C','T'),1,prob = PAM10[seq2[i - 1], ])
}
r1 = (3.821 + 21.193 + 2.615)*-1
r2 = (3.821 + 2.567 + 34.546)*-1
r3 = (21.193 + 2.567 + 1)*-1
r4 = (2.615 + 34.346 + 1)*-1
R = matrix(
c(r1, 3.821, 21.193, 2.615,
3.821, r2, 2.567, 34.546,
21.193, 2.567, r3, 1.000,
2.615, 34.546, 1.000, r4),
nrow = 4, ncol = 4)
piM <- matrix(
c(0.298, 0.249, 0.232, 0.221))
Q <-matrix(nrow = 4, ncol =4)
for(i in 1:4)
for(j in 1:4)
Q[i,j] <- R[i,j]*piM[j]
Q[1,1] <- (Q[1,2] + Q[1,3] + Q[1,4]) * -1
Q[2,2] <- (Q[2,1] + Q[2,3] + Q[2,4])* -1
Q[3,3] <- (Q[3,1] + Q[3,2] + Q[3,4])* -1
Q[4,4] <- (Q[4,2] + Q[4,3] + Q[4,1])* -1
P <- matrix(nrow = 4, ncol = 4)
for(i in 1:4)
for(j in 1:4)
{P[i,j] <- Q[i,j]/-Q[i,i]
if(i== j)
P[i,j] <- 0}
const <- 0
for(i in 1:4)
const = const + -Q[i,i]*piM[i]
R_norm <- matrix(nrow=4, ncol=4)
#Normalize R using q*pi
for(i in 1:4)
for(j in 1:4)
R_norm[i,j] <- R[i,j]/const
# Normalized R matrix
R
Q_norm <- matrix(nrow =4, ncol =4)
#Now calculate Q
for(i in 1:4)
for(j in 1:4)
Q_norm[i,j] <- R_norm[i,j]*piM[j]
Q_norm[1,1] <- (Q_norm[1,2] + Q_norm[1,3] + Q_norm[1,4])*-1
Q_norm[2,2] <- (Q_norm[2,1] + Q_norm[2,3] + Q_norm[2,4])*-1
Q_norm[3,3] <- (Q_norm[3,2] + Q_norm[3,1] + Q_norm[3,4])*-1
Q_norm[4,4] <- (Q_norm[4,2] + Q_norm[4,3] + Q_norm[4,1])*-1
# Normalized Q matrix
Q
p_norm<- matrix(nrow = 4, ncol = 4)
for(i in 1:4)
for(j in 1:4)
{p_norm[i,j] <- Q_norm[i,j]/-Q_norm[i,i]
if(i== j)
p_norm[i,j] <- 0}
k=1
for(i in 1:4){
for(j in 1:4){
p_norm_vect[k] <- Q_norm[i,j]/-Q_norm[i,i]
if(i== j)
p_norm_vect[k] <- 0
k=k+1
}
}
# Normalized P matrix
P
#Find the holding time,
MoV <- matrix(nrow = 4)
#Generate a new holding time for each run
rexp(1,-Q[1,1])
mat1 <- matrix(nrow = 1000)
for(z in 1:1000){
x0 <- rmultinom(1,1,piM)
for(i in 1:4){
if(x0[i] == 1){
x0_index <- i
holding_time <- rexp(1,-Q_norm[i,i])
break;
}
}
changes = 0
while(1){
if(holding_time < 2.5){
changes <- changes +  1
if(changes == 1){
x1 <- rmultinom(1, 1, p_norm[x0_index, ])
}else{
x1 <- rmultinom(1, 1, p_norm[x1_index, ])
}
for(i in 1:4){
if(x1[i] == 1){
x1_index <- i
break;
}
}
holding_time <- holding_time +  rexp(1,-Q_norm[x1_index,x1_index])
} else{
mat1[z] = changes
break
}
}
}
mean(mat1)
#To calculate the PAM_10
prod <- Q_norm * 0.01
PAM <- expm(prod)
PAM_10 <- PAM %^% 10
#To Calculate Pt
prod <- Q_norm * 0.1 #USe .01 for PAM_10, not for P(t)
Pt <- expm(prod)
# Homework 3 - BCB 568
# Written by: Jacqueline Richter
setwd("C:/Users/prichter/Desktop/Jackie")
require(expm)
## Inital Data -----------------------------------------------------------------------------
pi = c(.298,.249,.232,.221)
names(pi) = c('A','G','C','T')
R = matrix(c(0,3.821,21.193,2.615,
3.821,0,2.567,34.546,
21.193,2.567,0,1.000,
2.615,34.546,1.000,0),
nrow = 4, byrow = TRUE)
rownames(R) = c('A','G','C','T')
colnames(R) = c('A','G','C','T')
## Calculate Q matrix -----------------------------------------------------------------------
Q = matrix(0, nrow = 4, ncol = 4)
for(i in 1:nrow(R)) {
Q[i,] = R[i,] * pi
}
diag(Q) = -rowSums(Q)
rownames(Q) = c('A','G','C','T')
colnames(Q) = c('A','G','C','T')
## Embedded Discrete Markov Chain -----------------------------------------------------------
# I - diag(Q)^(-1) * Q
# http://en.wikipedia.org/wiki/Continuous-time_Markov_chain#Embedded_Markov_chain
embeddedMC = diag(4) - (diag(Q))^(-1) * Q #embeddedMC = p_ij
## Normalize Rate ---------------------------------------------------------------------------
# Normalize R to R.prime
R.prime = R/(-sum(diag(Q) * pi))
Q.prime = matrix(0, nrow = 4, ncol = 4)
# Calculate Q.prime from R.prime
for(i in 1:nrow(R.prime)) {
Q.prime[i,] = R.prime[i,] * pi
}
diag(Q.prime) = -rowSums(Q.prime)
rownames(Q.prime) = c('A','G','C','T')
colnames(Q.prime) = c('A','G','C','T')
# Instantaneous rates v
v.prime = -diag(Q.prime)
# names(v.prime) = c('A','G','C','T')
## Simulate CTMC ----------------------------------------------------------------------------
# Simulates a first-order CTMC where the expected number of changes is 2.5
# expected.value <- rep(0, 10000)
# for(j in 1:10000) {
# Initalize data frame
sim.MC <- data.frame(Time = NA, Nucleotide = NA)
counter = 1
t = 0
# Initial state
sim.MC[1,1] = t
sim.MC[1,2] = sample(c('A','G','C','T'), 1, prob = pi)
while(t < 2.5) {
# Randomly generate a time t from exponential
# with instantaneous rate of change.
t.prime = rexp(1, rate = v.prime[sim.MC[counter,2]])
t = t.prime + sim.MC[counter, 1]
nucl = sample(c('A','G','C','T'), 1, prob = embeddedMC[sim.MC[counter,2],])
sim.MC <- rbind(sim.MC, data.frame(Time = t, Nucleotide = nucl))
counter = counter + 1
}
expected.value[j] = nrow(sim.MC)
# }
# mean(expected.value)
# sim.MC
sim.MC[sim.MC$Nucleotide == 'A',2] <- 1
sim.MC[sim.MC$Nucleotide == 'G',2] <- 2
sim.MC[sim.MC$Nucleotide == 'C',2] <- 3
sim.MC[sim.MC$Nucleotide == 'T',2] <- 4
# Plot CTMC as a step function
CTMC.plot = stepfun(sim.MC$Time, c(sim.MC$Nucleotide, sim.MC[nrow(sim.MC), 2]))
plot.stepfun(CTMC.plot, do.points = FALSE,
yaxt='n', xaxt = 'n', xlim = c(0, sim.MC[nrow(sim.MC),1]),
ylim = c(0,4),xlab = "Time", ylab = "Nucleotide",
main = "Realization of CTMC : {X(t) : 0 <= t <= 2.5}")
# Y axis
axis(2, at = c(1,2,3,4), labels = c('A','G','C','T'))
# X axis
axis(1, at = seq(from = 0, to =  sim.MC[nrow(sim.MC),1], by = 0.5),
labels  = seq(from = 0, to =  sim.MC[nrow(sim.MC),1], by = 0.50))
abline(h = c(1,2,3,4), lty = 3, col = rgb(0,0,0, 0.5))
## Calculate PAM10 Matrix -----------------------------------------------------------------------
t = 0.1
P = expm(Q * t, method = "Taylor")
PAM10 = P
# PAM10 = P %*% P %*% P %*% P %*% P %*% P %*% P %*% P %*% P %*% P
rowSums(PAM10)
pi[1] * PAM10[1,2]
pi[2] * PAM10[2,1]
## Excursions ------------------------------------------------------------------------------------
n = 100
# counter = 1
seq1 <- rep(NA, n)
seq2 <- rep(NA, n)
# Initial State
# seq1[1] = sample(c('A','G','C','T'), 1, prob = pi)
# seq2[1] = sample(c('A','G','C','T'), 1, prob = pi)
# Generate sequences
for(i in 1:n) {
seq1[i] = sample(c('A','G','C','T'), 1, prob = pi)
seq2[i] = sample(c('A','G','C','T'), 1, prob = pi)
#   seq1[i] = sample(c('A','G','C','T'),1, prob = PAM10[seq1[i - 1], ])
#  seq2[i] = sample(c('A','G','C','T'),1,prob = PAM10[seq2[i - 1], ])
}
# Frequencies of nucleotides in seq1
p <- c(rep(NA, 4))
p[1] <- length(seq1[seq1 == 'A'])/length(seq1)
p[2] <- length(seq1[seq1 == 'G'])/length(seq1)
p[3] <- length(seq1[seq1 == 'C'])/length(seq1)
p[4] <- length(seq1[seq1 == 'T'])/length(seq1)
names(p) = c('A','G','C','T')
# Frequencies of nucleotides in seq2
q <- c(rep(NA, 4))
q[1] <- length(seq2[seq2 == 'A'])/length(seq2)
q[2] <- length(seq2[seq2 == 'G'])/length(seq2)
q[3] <- length(seq2[seq2 == 'C'])/length(seq2)
q[4] <- length(seq2[seq2 == 'T'])/length(seq2)
names(q) = c('A','G','C','T')
# Calculate scoring matrix
S = matrix(0, nrow = 4, ncol = 4)
for(j in 1:nrow(PAM10)) {
for(k in 1:ncol(PAM10)) {
S[j,k] = log(PAM10[j,k]/q[k])
}
}
rownames(S) = c('A','G','C','T')
colnames(S) = c('A','G','C','T')
excursions <- data.frame(Score = rep(0,n + 1), Ladder = rep(NA, n +1), exc_height = rep(0, n+1), max_height = rep(0, n+ 1))
excursions[1,2] <- TRUE
for(i in 1:n) {
# Calculate Score
excursions[i + 1,1] <- S[seq1[i], seq2[i]]
# Calculate height
excursions[i + 1,3] <- excursions[i, 3] + S[seq1[i], seq2[i]]
# Determine ladder points
if(excursions[i + 1, 3] < excursions[i, 3]) {
excursions[i + 1,2] <- TRUE
excursions[i, 2] <- FALSE
} else {
excursions[i + 1, 2] <- FALSE
}
}
i = 2
while(i <= n) {
max = 0
while(excursions[i,2] == FALSE) {
if(excursions[i,3] > excursions[i- 1,3]) {
max = excursions[i,3]
}
i = i + 1
}
excursions[i,4] = max
i = i + 1
}
lambda = 0
for(j in 1:4) {
for(k in 1:4) {
lambda = lambda + log(1/(p[j] * q[k]))/S[j,k]
}
}
names(lambda) <- c('lambda')
lambda
install.packages("lmtest")
library("lmtest")
??lmtest
A1 -3676.15257
Ao -3682.12146
D <- 2*(-3676.15257 + 3681.12146)
df <- 1
1-pchisq(D, df = 1) # We should use GTR
?pchisq
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
library(devtools)
install_github("sctyner/ggplot2")
library(devtools)
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
remove.packages('ggplot2')
install_github("sctyner/ggplot2")
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
remove.packages('ggplot2')
install_github("hadley/ggplot2")
library(devtools)
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
shiny::runApp('Dropbox/Iowa_Research/Research with Professor Cook/R_Code/Playing_around/App-8')
shiny::runApp('Dropbox/Iowa_Research/3rd Rotation')
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
remove.packages('ggplot2')
install.packages('ggplot2')
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
xlab="", ylab="Miles per Gallon")
# ggplot2 examples
library(ggplot2)
# create factors with value labels
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),
labels=c("3gears","4gears","5gears"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),
labels=c("Automatic","Manual"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),
labels=c("4cyl","6cyl","8cyl"))
# Kernel density plots for mpg
# grouped by number of gears (indicated by color)
qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
# Scatterplot of mpg vs. hp for each combination of gears and cylinders
# in each facet, transmittion type is represented by shape and color
qplot(hp, mpg, data=mtcars, shape=am, color=am,
facets=gear~cyl, size=I(3),
xlab="Horsepower", ylab="Miles per Gallon")
# Separate regressions of mpg on weight for each number of cylinders
qplot(wt, mpg, data=mtcars, geom=c("point", "smooth"),
method="lm", formula=y~x, color=cyl,
main="Regression of MPG on Weight",
xlab="Weight", ylab="Miles per Gallon")
# Boxplots of mpg by number of gears
# observations (points) are overlayed and jittered
qplot(gear, mpg, data=mtcars, geom=c("boxplot", "jitter"),
fill=gear, main="Mileage by Gear Number",
xlab="", ylab="Miles per Gallon")
remove.packages('ggplot2')
qplot(wt, mpg, data=mtcars, geom=c("point", "smooth"),
# ggplot2 examples
library(ggplot2)
# create factors with value labels
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),
labels=c("3gears","4gears","5gears"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),
labels=c("Automatic","Manual"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),
labels=c("4cyl","6cyl","8cyl"))
# Kernel density plots for mpg
# grouped by number of gears (indicated by color)
qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
# Scatterplot of mpg vs. hp for each combination of gears and cylinders
# in each facet, transmittion type is represented by shape and color
qplot(hp, mpg, data=mtcars, shape=am, color=am,
facets=gear~cyl, size=I(3),
xlab="Horsepower", ylab="Miles per Gallon")
# Separate regressions of mpg on weight for each number of cylinders
qplot(wt, mpg, data=mtcars, geom=c("point", "smooth"),
method="lm", formula=y~x, color=cyl,
main="Regression of MPG on Weight",
xlab="Weight", ylab="Miles per Gallon")
# Boxplots of mpg by number of gears
# observations (points) are overlayed and jittered
qplot(gear, mpg, data=mtcars, geom=c("boxplot", "jitter"),
fill=gear, main="Mileage by Gear Number",
xlab="", ylab="Miles per Gallon")
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
# ggplot2 examples
library(ggplot2)
# create factors with value labels
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),
labels=c("3gears","4gears","5gears"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),
labels=c("Automatic","Manual"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),
labels=c("4cyl","6cyl","8cyl"))
# Kernel density plots for mpg
# grouped by number of gears (indicated by color)
qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
# Scatterplot of mpg vs. hp for each combination of gears and cylinders
# in each facet, transmittion type is represented by shape and color
qplot(hp, mpg, data=mtcars, shape=am, color=am,
facets=gear~cyl, size=I(3),
xlab="Horsepower", ylab="Miles per Gallon")
# Separate regressions of mpg on weight for each number of cylinders
qplot(wt, mpg, data=mtcars, geom=c("point", "smooth"),
method="lm", formula=y~x, color=cyl,
main="Regression of MPG on Weight",
xlab="Weight", ylab="Miles per Gallon")
# Boxplots of mpg by number of gears
# observations (points) are overlayed and jittered
qplot(gear, mpg, data=mtcars, geom=c("boxplot", "jitter"),
fill=gear, main="Mileage by Gear Number",
xlab="", ylab="Miles per Gallon")
dat <- data.frame(
time = factor(c("Lunch","Dinner"), levels=c("Lunch","Dinner")),
total_bill = c(14.89, 17.23)
)
dat
#>     time total_bill
#> 1  Lunch      14.89
#> 2 Dinner      17.23
# Load the ggplot2 package
library(ggplot2)
# Very basic bar graph
ggplot(data=dat, aes(x=time, y=total_bill)) +
geom_bar(stat="identity")
# Map the time of day to different fill colors
ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) +
geom_bar(stat="identity")
## This would have the same result as above
# ggplot(data=dat, aes(x=time, y=total_bill)) +
#    geom_bar(aes(fill=time), stat="identity")
# Add a black outline
ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) +
geom_bar(colour="black", stat="identity")
# No legend, since the information is redundant
ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) +
geom_bar(colour="black", stat="identity") +
guides(fill=FALSE)
ggplot(data=dat, aes(x=time, y=total_bill)) +
geom_bar(stat="identity")
ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) +
geom_bar(colour="black", stat="identity")
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
remove.packages('ggplot2')
install_github("hadley/ggplot2")
install_github("hadley/ggplot2")
install_github("hadley/ggplot2")
install_github("sctyner/ggplot2")
shiny::runApp('Dropbox/Iowa_Research/4th_rotation/shinyApp')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
shiny::runApp('Dropbox/Google_Summer_of_Code_2015/nlmeviz')
wd
setwd
pwd
getwd
getwd()
library(shiny)
setwd("/Users/Nafiz/Dropbox/Google_Summer_of_Code_2015")
runApp("nlmeviz")
shiny::runApp('nlmeviz')
shiny::runApp('nlmeviz')
shiny::runApp('nlmeviz')
shiny::runApp('nlmeviz')
shiny::runApp('nlmeviz')
shiny::runApp('nlmeviz')
getwd()
setwd("/Users/Nafiz/Dropbox/Google_Summer_of_Code_2015/nlmeviz/")
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
